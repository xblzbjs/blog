<!DOCTYPE html>
<html lang="zh-cn">
    <head>
        <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="author" content="map[name:xblzbjs]">
<meta name="description" content="因何而生❓ 有时测试程序需要在测试之前或之后进行额外的设置或拆卸。有时测试还需要控制哪些代码在主线程上运行。为了支持这些和其他情况, testing 包提供了 TestMain 函数 :
func TestMain(m *testing.M) 有什么作用🤔 如果测试文件中包含该函数，那么生成的测试将调用 TestMain(m)，而不是直接运行测试。TestMain 运行在主 goroutine 中 , 可以在调用 m.Run 前后做任何设置和拆卸。m. Run将返回可能传递给的退出代码操作系统退出. 如果TestMain返回，测试包装器将m.Run的结果传递给操作系统退出它自己
调用TestMain时，flag.解析尚未运行。如果TestMain依赖于命令行标志，包括测试包的标志，那么它应该调用flag.解析明确地。命令行标志总是由运行的时间测试或基准函数来解析
因此，当您需要为测试执行一些全局设置/删除时，这可能会很方便
举个🌰 简单 // file name: demo_test.go package tests import ( &amp;#34;testing&amp;#34; &amp;#34;os&amp;#34; ) func TestMain(m *testing.M) { log.Println(&amp;#34;Do stuff BEFORE the tests!&amp;#34;) exitVal := m.Run() log.Println(&amp;#34;Do stuff AFTER the tests!&amp;#34;) os.Exit(exitVal) } func TestA(t *testing.T) { log.Println(&amp;#34;TestA running&amp;#34;) } func TestB(t *testing.T) { log.Println(&amp;#34;TestB running&amp;#34;) } 输出 $ go test -v demo_test." />
<meta name="keywords" content="" />
<meta name="robots" content="noodp" />
<meta name="theme-color" content="" />
<link rel="canonical" href="https://xblzbjs.cn/article/2021/03/gotesting.m/" />


    <title>
        
            Go｜testing.M :: 行百里者半九十 
        
    </title>



<link href="https://cdnjs.cloudflare.com/ajax/libs/flag-icon-css/3.5.0/css/flag-icon.min.css" rel="stylesheet"
    type="text/css">



<link rel="stylesheet" href="https://xblzbjs.cn/main.d7bdd8ee18bfbf4c605488a7e5b1b92cd980dfeed2bdaeab4dd5e931a7a78bc0.css">




    <link rel="apple-touch-icon" sizes="180x180" href="https://xblzbjs.cn/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="https://xblzbjs.cn/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="https://xblzbjs.cn/favicon-16x16.png">
    <link rel="manifest" href="https://xblzbjs.cn/site.webmanifest">
    <link rel="mask-icon" href="https://xblzbjs.cn/safari-pinned-tab.svg" color="#1b1c1d">
    <link rel="shortcut icon" href="https://xblzbjs.cn/favicon.ico">
    <meta name="msapplication-TileColor" content="#1b1c1d">
    <meta name="theme-color" content="#1b1c1d">



<meta itemprop="name" content="Go｜testing.M">
<meta itemprop="description" content="因何而生❓ 有时测试程序需要在测试之前或之后进行额外的设置或拆卸。有时测试还需要控制哪些代码在主线程上运行。为了支持这些和其他情况, testing 包提供了 TestMain 函数 :
func TestMain(m *testing.M) 有什么作用🤔 如果测试文件中包含该函数，那么生成的测试将调用 TestMain(m)，而不是直接运行测试。TestMain 运行在主 goroutine 中 , 可以在调用 m.Run 前后做任何设置和拆卸。m. Run将返回可能传递给的退出代码操作系统退出. 如果TestMain返回，测试包装器将m.Run的结果传递给操作系统退出它自己
调用TestMain时，flag.解析尚未运行。如果TestMain依赖于命令行标志，包括测试包的标志，那么它应该调用flag.解析明确地。命令行标志总是由运行的时间测试或基准函数来解析
因此，当您需要为测试执行一些全局设置/删除时，这可能会很方便
举个🌰 简单 // file name: demo_test.go package tests import ( &#34;testing&#34; &#34;os&#34; ) func TestMain(m *testing.M) { log.Println(&#34;Do stuff BEFORE the tests!&#34;) exitVal := m.Run() log.Println(&#34;Do stuff AFTER the tests!&#34;) os.Exit(exitVal) } func TestA(t *testing.T) { log.Println(&#34;TestA running&#34;) } func TestB(t *testing.T) { log.Println(&#34;TestB running&#34;) } 输出 $ go test -v demo_test."><meta itemprop="datePublished" content="2021-03-24T00:00:00&#43;00:00" />
<meta itemprop="dateModified" content="2021-03-24T00:00:00&#43;00:00" />
<meta itemprop="wordCount" content="193"><meta itemprop="image" content="https://xblzbjs.cn"/>
<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://xblzbjs.cn"/>

<meta name="twitter:title" content="Go｜testing.M"/>
<meta name="twitter:description" content="因何而生❓ 有时测试程序需要在测试之前或之后进行额外的设置或拆卸。有时测试还需要控制哪些代码在主线程上运行。为了支持这些和其他情况, testing 包提供了 TestMain 函数 :
func TestMain(m *testing.M) 有什么作用🤔 如果测试文件中包含该函数，那么生成的测试将调用 TestMain(m)，而不是直接运行测试。TestMain 运行在主 goroutine 中 , 可以在调用 m.Run 前后做任何设置和拆卸。m. Run将返回可能传递给的退出代码操作系统退出. 如果TestMain返回，测试包装器将m.Run的结果传递给操作系统退出它自己
调用TestMain时，flag.解析尚未运行。如果TestMain依赖于命令行标志，包括测试包的标志，那么它应该调用flag.解析明确地。命令行标志总是由运行的时间测试或基准函数来解析
因此，当您需要为测试执行一些全局设置/删除时，这可能会很方便
举个🌰 简单 // file name: demo_test.go package tests import ( &#34;testing&#34; &#34;os&#34; ) func TestMain(m *testing.M) { log.Println(&#34;Do stuff BEFORE the tests!&#34;) exitVal := m.Run() log.Println(&#34;Do stuff AFTER the tests!&#34;) os.Exit(exitVal) } func TestA(t *testing.T) { log.Println(&#34;TestA running&#34;) } func TestB(t *testing.T) { log.Println(&#34;TestB running&#34;) } 输出 $ go test -v demo_test."/>




    <meta property="og:title" content="Go｜testing.M" />
<meta property="og:description" content="因何而生❓ 有时测试程序需要在测试之前或之后进行额外的设置或拆卸。有时测试还需要控制哪些代码在主线程上运行。为了支持这些和其他情况, testing 包提供了 TestMain 函数 :
func TestMain(m *testing.M) 有什么作用🤔 如果测试文件中包含该函数，那么生成的测试将调用 TestMain(m)，而不是直接运行测试。TestMain 运行在主 goroutine 中 , 可以在调用 m.Run 前后做任何设置和拆卸。m. Run将返回可能传递给的退出代码操作系统退出. 如果TestMain返回，测试包装器将m.Run的结果传递给操作系统退出它自己
调用TestMain时，flag.解析尚未运行。如果TestMain依赖于命令行标志，包括测试包的标志，那么它应该调用flag.解析明确地。命令行标志总是由运行的时间测试或基准函数来解析
因此，当您需要为测试执行一些全局设置/删除时，这可能会很方便
举个🌰 简单 // file name: demo_test.go package tests import ( &#34;testing&#34; &#34;os&#34; ) func TestMain(m *testing.M) { log.Println(&#34;Do stuff BEFORE the tests!&#34;) exitVal := m.Run() log.Println(&#34;Do stuff AFTER the tests!&#34;) os.Exit(exitVal) } func TestA(t *testing.T) { log.Println(&#34;TestA running&#34;) } func TestB(t *testing.T) { log.Println(&#34;TestB running&#34;) } 输出 $ go test -v demo_test." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://xblzbjs.cn/article/2021/03/gotesting.m/" /><meta property="og:image" content="https://xblzbjs.cn"/><meta property="article:section" content="article" />
<meta property="article:published_time" content="2021-03-24T00:00:00&#43;00:00" />
<meta property="article:modified_time" content="2021-03-24T00:00:00&#43;00:00" /><meta property="og:site_name" content="行百里者半九十" />






    <meta property="article:section" content="Golang" />



    <meta property="article:published_time" content="2021-03-24 00:00:00 &#43;0000 UTC" />








    </head>

    
        <body>
    
    
        <div class="container">
            <header class="header">
    <span class="header__inner">
        <a href="https://xblzbjs.cn/" style="text-decoration: none;">
    <div class="logo">
        
            <span class="logo__mark">></span>
            <span class="logo__text">行百里者半九十</span>
            <span class="logo__cursor" style=
                  "
                   
                   ">
            </span>
        
    </div>
</a>


        <span class="header__right">
            
                <nav class="menu">
    <ul class="menu__inner"><li><a href="https://xblzbjs.cn/book-list">书单</a></li><li><a href="https://xblzbjs.cn/page/about/">关于</a></li><li><a href="https://xblzbjs.cn/page/archives/">归档</a></li><li><a href="https://xblzbjs.cn/article">随笔</a></li>
    </ul>
</nav>

                <span class="menu-trigger">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                        <path d="M0 0h24v24H0z" fill="none"/>
                        <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
                    </svg>
                </span>
            
        </span>
    </span>
</header>


            <div class="content">
                
    <main class="post">

        <div class="post-info">
            
            </p>
        </div>

        <article>
            <h2 class="post-title"><a href="https://xblzbjs.cn/article/2021/03/gotesting.m/">Go｜testing.M</a></h2>

            
            
            

            <div class="post-content">
                <h2 id="因何而生">因何而生❓</h2>
<p>有时测试程序需要在测试之前或之后进行额外的设置或拆卸。有时测试还需要控制哪些代码在主线程上运行。为了支持这些和其他情况, <code>testing</code> 包提供了 <code>TestMain</code> 函数 :</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">TestMain</span>(<span style="color:#a6e22e">m</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">testing</span>.<span style="color:#a6e22e">M</span>)
</code></pre></div><h2 id="有什么作用">有什么作用🤔</h2>
<p>如果测试文件中包含该函数，那么生成的测试将调用 <code>TestMain(m)</code>，而不是直接运行测试。<code>TestMain</code> 运行在主 goroutine 中 , 可以在调用 <code>m.Run</code> 前后做任何设置和拆卸。<code>m. Run</code>将返回可能传递给的退出代码操作系统退出. 如果TestMain返回，测试包装器将m.Run的结果传递给操作系统退出它自己</p>
<p>调用TestMain时，flag.解析尚未运行。如果TestMain依赖于命令行标志，包括测试包的标志，那么它应该调用flag.解析明确地。命令行标志总是由运行的时间测试或基准函数来解析</p>
<p>因此，当您需要为测试执行一些全局设置/删除时，这可能会很方便</p>
<h2 id="举个">举个🌰</h2>
<h3 id="简单">简单</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// file name: demo_test.go
</span><span style="color:#75715e"></span><span style="color:#f92672">package</span> <span style="color:#a6e22e">tests</span>

<span style="color:#f92672">import</span> (
    <span style="color:#e6db74">&#34;testing&#34;</span>
    <span style="color:#e6db74">&#34;os&#34;</span>
)

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">TestMain</span>(<span style="color:#a6e22e">m</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">testing</span>.<span style="color:#a6e22e">M</span>) {
    <span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Do stuff BEFORE the tests!&#34;</span>)
    <span style="color:#a6e22e">exitVal</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">Run</span>()
    <span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Do stuff AFTER the tests!&#34;</span>)
    <span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Exit</span>(<span style="color:#a6e22e">exitVal</span>)
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">TestA</span>(<span style="color:#a6e22e">t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">testing</span>.<span style="color:#a6e22e">T</span>) {
    <span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;TestA running&#34;</span>)
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">TestB</span>(<span style="color:#a6e22e">t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">testing</span>.<span style="color:#a6e22e">T</span>) {
    <span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;TestB running&#34;</span>)
}
</code></pre></div><h4 id="输出">输出</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ go test -v demo_test.go
2021/03/24 11:01:06 Do stuff BEFORE the tests!
<span style="color:#f92672">===</span> RUN   TestA
2021/03/24 11:01:06 TestA running
--- PASS: TestA <span style="color:#f92672">(</span>0.00s<span style="color:#f92672">)</span>
<span style="color:#f92672">===</span> RUN   TestB
2021/03/24 11:01:06 TestB running
--- PASS: TestB <span style="color:#f92672">(</span>0.00s<span style="color:#f92672">)</span>
PASS
2021/03/24 11:01:06 Do stuff AFTER the tests!
</code></pre></div><h3 id="复杂">复杂</h3>
<p>假设在测试之前需要对数据库进行一些配置，不使用<code>Testmain</code>函数可能需要这么写</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">TestDBFeatureA</span>(<span style="color:#a6e22e">t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">testing</span>.<span style="color:#a6e22e">T</span>) {
    <span style="color:#a6e22e">models</span>.<span style="color:#a6e22e">TestDBManager</span>.<span style="color:#a6e22e">Setup</span>()
    <span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">models</span>.<span style="color:#a6e22e">TestDBManager</span>.<span style="color:#a6e22e">Exit</span>()

    <span style="color:#75715e">// Do the tests
</span><span style="color:#75715e"></span>}
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">TestDBFeatureB</span>(<span style="color:#a6e22e">t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">testing</span>.<span style="color:#a6e22e">T</span>) {
    <span style="color:#a6e22e">models</span>.<span style="color:#a6e22e">TestDBManager</span>.<span style="color:#a6e22e">Setup</span>()
    <span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">models</span>.<span style="color:#a6e22e">TestDBManager</span>.<span style="color:#a6e22e">Exit</span>()

    <span style="color:#75715e">// Do the tests
</span><span style="color:#75715e"></span>}
</code></pre></div><p>有了<code>Testmain</code>后，配置更为简单清晰</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">TestDBFeatureA</span>(<span style="color:#a6e22e">t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">testing</span>.<span style="color:#a6e22e">T</span>) {
    <span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">models</span>.<span style="color:#a6e22e">TestDBManager</span>.<span style="color:#a6e22e">Reset</span>()

    <span style="color:#75715e">// Do the tests
</span><span style="color:#75715e"></span>}
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">TestDBFeatureB</span>(<span style="color:#a6e22e">t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">testing</span>.<span style="color:#a6e22e">T</span>) {
    <span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">models</span>.<span style="color:#a6e22e">TestDBManager</span>.<span style="color:#a6e22e">Reset</span>()

    <span style="color:#75715e">// Do the tests
</span><span style="color:#75715e"></span>}
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">TestMain</span>(<span style="color:#a6e22e">m</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">testing</span>.<span style="color:#a6e22e">M</span>) {
    <span style="color:#a6e22e">models</span>.<span style="color:#a6e22e">TestDBManager</span>.<span style="color:#a6e22e">Setup</span>()
    <span style="color:#75715e">// os.Exit() does not respect defer statements
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">code</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">Run</span>()
    <span style="color:#a6e22e">models</span>.<span style="color:#a6e22e">TestDBManager</span>.<span style="color:#a6e22e">Exit</span>()
    <span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Exit</span>(<span style="color:#a6e22e">code</span>)
}
</code></pre></div><p>虽然每个测试都必须在自身完成后进行清理，但这只涉及恢复初始数据，这比进行模式迁移要快得多。这种方法还减少了代码重复，在每个测试中只有一行用于数据库管理，而不是两行，运行速度会快得多。</p>
<h2 id="注意">注意⚠️</h2>
<ul>
<li><code>testing.M</code>有一个名为<code>Run（）</code>的已定义函数，它运行包中的所有测试。<code>Run（）</code>返回可以传递给的退出代码操作系统退出.</li>
<li>在 <code>TestMain</code> 函数的最后，应该使用 <code>m.Run</code> 的返回值作为参数去调用 <code>os.Exit</code>(见官方例子)。</li>
<li>如果不调用<code>os.Exit</code>，那测试命令将返回0（测试失败）</li>
<li>由于函数名在包中需要唯一，因此只能为每个包定义一次<code>TestMain</code>。如果包下有多个测试文件，最好在<code>TestMain</code>函数中进行逻辑判断。</li>
</ul>
<h2 id="总结">总结📒</h2>
<p><code>TestMain</code>函数很好，但并不是所有的包都需要实现<code>TestMain</code>。如果团队使用第三方测试框架仅仅用到了设置和拆卸功能，这种情况下就可以考虑简化，用go提供的<code>TestMain</code>函数来进行配置。</p>

            </div>
        </article>

        <hr />

        <div class="post-info">
            
            
    <p>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-folder meta-icon"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path></svg>

        <span class="tag"><a href="https://xblzbjs.cn/categories/golang/">Golang</a></span>
        
    </p>

  		</div>
    </main>

            </div>

            
                <footer class="footer">
    <div class="footer__inner">
        <div class="footer__content">
            <span>&copy; 2021</span>
            <span><a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">xblzbjs</a></span><span><a href="https://xblzbjs.cn/posts/index.xml" target="_blank" title="rss"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></a></span>
        </div>
    </div>
    <div class="footer__inner">
        <div class="footer__content">
            <span>粤ICP备2021007187号-1</span>
          </div>
    </div>
</footer>

            
        </div>

        



<script type="text/javascript" src="https://xblzbjs.cn/bundle.min.2ce64ea6ea44a72b13dd812fc2eb5cca3efe878cce258a47c137c17edf46e0602a05e422b618a5b80b5939c731b7a293351c2f2222a21f6ee27e54a8448dd20e.js" integrity="sha512-LOZOpupEpysT3YEvwutcyj7&#43;h4zOJYpHwTfBft9G4GAqBeQithiluAtZOccxt6KTNRwvIiKiH27iflSoRI3SDg=="></script>
    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-192697137-1', 'auto');
	
	ga('send', 'pageview');
}
</script>



    </body>
</html>
