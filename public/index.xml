<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>行百里者半九十</title>
    <link>https://xblzbjs.cn/</link>
    <description>Recent content on 行百里者半九十</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-Hans</language>
    <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;xblzbjs&lt;/a&gt;</copyright>
    <lastBuildDate>Sat, 20 Mar 2021 13:45:56 +0800</lastBuildDate><atom:link href="https://xblzbjs.cn/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Python｜创建型设计模式</title>
      <link>https://xblzbjs.cn/articles/python%E5%88%9B%E5%BB%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sat, 20 Mar 2021 13:45:56 +0800</pubDate>
      
      <guid>https://xblzbjs.cn/articles/python%E5%88%9B%E5%BB%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid>
      <description>常见创建型设计模式：  工厂模式（Factory）：解决对象创建问题 构造模式（Builder）：控制复杂对象的创建 原型模式（Prototype）：通过原型的克隆创建新的实例 单例（Borg/Singleton）：一个类只能创建同一个对象 对象池模式（Pool）：预先分配同一类型的一组实例 惰性计算模式（Lazy Evaluation）：延迟计算（python的property）  1.工厂模式 什么是工厂模式：
 解决对象创建问题 解耦对象的创建和使用 包括工厂方法和抽象工厂  # 工厂方法 class DogToy: def speak(self): print(&amp;#34;wang wang&amp;#34;) class CatToy: def speak(self): print(&amp;#34;miao miao&amp;#34;) def toy_factory(toy_type): if toy_type == &amp;#39;dog&amp;#39;: return DogToy() elif toy_type == &amp;#39;cat&amp;#39;: return CatToy() 2.构造模式 什么是构造模式：
 用来控制复杂对象的构造 创建和表示分离。比如你要买电脑，工厂模式直接给你需要的电脑 但是构造模式允许你自己定义电脑的配置，组装完成后给你  3.原型模式 什么是原型模式：
 通过克隆原型来创建新的实例 可以通过相同的原型，通过修改部分属性来创建新的实例 用途：对于一些创建实例开销比较高的地方可以用原型模式  4.单例模式（重点） 单例模式的实现由多种方式
 单例模式：一个类创建出来的对象都是同一个 Python的模块其实就是单例的，只会导入一次（import） 使用共享同一个实例的方式来创建单例模式  # 单例模式 class Singleton: def __new__(cls, *args, **kwargs): if not hasattr(cls, &amp;#39;_instance&amp;#39;): _instance = super().</description>
    </item>
    
    <item>
      <title>Python｜结构型设计模式</title>
      <link>https://xblzbjs.cn/articles/python%E7%BB%93%E6%9E%84%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sat, 20 Mar 2021 13:45:56 +0800</pubDate>
      
      <guid>https://xblzbjs.cn/articles/python%E7%BB%93%E6%9E%84%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid>
      <description>结构型模式 常见的结构型设计模式：
 工厂模式（Factory）：解决对象创建问题 构造模式（Builder）：控制复杂对象的创建 原型模式（Prototype）：通过原型的克隆创建新的实例 单例（Borg/Singleton）：一个类只能创建同一个对象 对象池模式（Pool）：预先分配同一类型的一组实例 惰性计算模式（Lazy Evaluation）：延迟计算（python的property）  装饰器模式 什么是装饰器（Decorator）
 Python中一切皆对象，函数也可以当作参数传递 装饰器是接受函数作为参数，添加功能后返回一个新函数的函数（类） 通过@使用装饰器  import time def log_time(func):	# 接受一个函数作为参数 def _log(*args, **kwargs): beg = time.time() res = func(*args, **kwargs) print(&amp;#39;use time:{}&amp;#39;.format(time.time()-beg)) return res return _log @log_time # @:装饰器语法糖 def mysleep(): time.sleep(1) newsleep = log_time(mysleep) # 等价于mysleep() newsleep() mysleep() import time # 装饰器类实现 class LogTime: def __init__(self, use_int=False): self.use_int = use_int	# 增加参数 def __call__(self,func):	def _log(*args, **kwargs): beg = time.</description>
    </item>
    
    <item>
      <title>Python｜行为型设计模式</title>
      <link>https://xblzbjs.cn/articles/python%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sat, 20 Mar 2021 13:45:56 +0800</pubDate>
      
      <guid>https://xblzbjs.cn/articles/python%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid>
      <description>常见学习行为型设计模式  迭代器模式（Iterator）：通过统一的接口迭代对象 观察者模式（Observer）：对象发生改变的时候，观察者执行相应动作 策略模式（Strategy）：针对不同规模输入使用不同的策略  迭代器模式  Python内置对迭代器模式的支持 可用for遍历各种Iterable的数据类型 可以实现__next__和__iter__实现迭代器  class Stack(object): # 使用组合的例子 def __init__(self): self._deque = deque() def push(self, value): return self._deque.append(value) def pop(self): return self._deque.pop() def empty(self): return len(self._deque) == 0 def __iter__(self): res = [] for i in self._deque: res.append(i) for i in reversed(res): yield i s = Stack() s.push(1) s.push(2) for i in s: print(i) 观察者模式  发布订阅是一种最常用的实现方式 发布订阅用于解耦逻辑 可以通过回调等方式实现，当发生事件，执行回调函数  ==TODO：代码实现==
策略模式  根据不同的输入采用不同的策略 对外暴露统一的接口，内部采用不同的策略计算  ==TODO：代码实现==</description>
    </item>
    
    <item>
      <title>关于我</title>
      <link>https://xblzbjs.cn/about/</link>
      <pubDate>Sat, 20 Mar 2021 13:44:44 +0800</pubDate>
      
      <guid>https://xblzbjs.cn/about/</guid>
      <description>一个不知名的Golang/Python后端工程师，目前正在往全栈工程师方向前进。</description>
    </item>
    
    <item>
      <title>2021书单</title>
      <link>https://xblzbjs.cn/book-list/2021/</link>
      <pubDate>Sat, 20 Mar 2021 13:44:38 +0800</pubDate>
      
      <guid>https://xblzbjs.cn/book-list/2021/</guid>
      <description>技术类： Golang  《The way to Go》 《Go高级编程》 《Go专家编程》(任洪彩著)  Python 其他  《启示录:打造用户喜爱的产品》(Marty Cagan著)(强烈推荐) 《软技能:代码之外的生存指南》(John Z.Sonmez著)    </description>
    </item>
    
    <item>
      <title>zsh｜主题</title>
      <link>https://xblzbjs.cn/articles/zsh%E4%B8%BB%E9%A2%98/</link>
      <pubDate>Fri, 19 Mar 2021 13:24:17 +0800</pubDate>
      
      <guid>https://xblzbjs.cn/articles/zsh%E4%B8%BB%E9%A2%98/</guid>
      <description>zsh Themes(主题) 所有主题 我喜欢的自带主题： agnoster amuse awesomepanda clean crcandy frisk jonathan linuxonly（只能运行在linux） nanotech philips pmcgee xiong-chiamiov 额外的主题 powerlevel10k spaceship-prompt </description>
    </item>
    
    <item>
      <title>Git｜合并分支</title>
      <link>https://xblzbjs.cn/articles/git%E5%90%88%E5%B9%B6%E5%88%86%E6%94%AF/</link>
      <pubDate>Fri, 19 Mar 2021 11:41:13 +0800</pubDate>
      
      <guid>https://xblzbjs.cn/articles/git%E5%90%88%E5%B9%B6%E5%88%86%E6%94%AF/</guid>
      <description>首先查看当前项目有哪些分支git branch -a等同于 git branch -all
git branch -a 输入后会看到当前项目的所有分支（其中带*的分支为当前分支）
dev *main 假设你需要在dev分支上进行开发，则需要切换到该分支
git checkout dev 这个时候再使用git branch -a命令就会发现当前分支为dev分支
*dev main 在dev分支上进行开发，提交测试没有问题想合并到main分支上，需要进行以下几步:
  查看当前分支的状态并
git status   添加更改文件push到当前分支上
git add . &amp;amp;&amp;amp; git commit -m &amp;#34;update&amp;#34;   将dev分支合并到main分支
git merge dev   检查main分支是否和dev分支的区别（当前处于div分支）
git diff main   </description>
    </item>
    
    <item>
      <title>MongoDB｜CRUD操作</title>
      <link>https://xblzbjs.cn/articles/mongodbcrud%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Wed, 17 Mar 2021 11:26:44 +0800</pubDate>
      
      <guid>https://xblzbjs.cn/articles/mongodbcrud%E6%93%8D%E4%BD%9C/</guid>
      <description>MongoDB的CRUD操作 Create(创建) insertOne()方法 ### insertOne()方法 # 参数含义 db.collection·insertOne() db.&amp;lt;collection&amp;gt;·insertOne( &amp;lt;document&amp;gt; writeConcern：&amp;lt;document&amp;gt;	# &amp;lt;collection&amp;gt;表示写入的集合 # &amp;lt;document&amp;gt;要替换成要写入的文档本身 # writeConcern：&amp;lt;document&amp;gt;定义了本次文档创建操作的安全写级别 ) # 简单来说，安全写级别用来判断一次数据库写入操作是否成功 安全写级别越高，丢失数据的风险就越低，然而写入操作的延迟也可能更高。如果不提供writeconcern文档，用默认的安全写级别。 # 创建单个文档 &amp;gt; db.accounts.insertOne(	# 虽然没有创建过accounts的集合，但该命令会自动创建相应的集合 ... { ... _id: &amp;#34;account1&amp;#34;, ... name: &amp;#34;alice&amp;#34;, ... balance: 100, ... } ... ) { &amp;#34;acknowledged&amp;#34; : true, &amp;#34;insertedId&amp;#34; : &amp;#34;account1&amp;#34; } # &amp;#34;acknowledged&amp;#34;: true表示安全写级别被启用 # 由于在db.collection.insertone()命令中没有提供writeConcern文档，这里显示的是默认的安全写级别启用状态 # &amp;#34;insertedId&amp;#34;显示了被写入的文档的_id # 重复_id创建一个新文档及相对应的报错信息 &amp;gt; db.accounts.insertOne( ... { ... _id: &amp;#34;account1&amp;#34;, ... name: &amp;#34;bob&amp;#34;, ... balance: 50 .</description>
    </item>
    
    <item>
      <title>MongoDB｜介绍与安装</title>
      <link>https://xblzbjs.cn/articles/mongodb%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%AE%89%E8%A3%85/</link>
      <pubDate>Wed, 17 Mar 2021 11:21:44 +0800</pubDate>
      
      <guid>https://xblzbjs.cn/articles/mongodb%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%AE%89%E8%A3%85/</guid>
      <description>MongoDB介绍 MongoDB安装 使用docker安装（推荐） docker pull mongo	# 默认最新 docker pull mongo:4.0 # 指定安装MongoDB4.0版本 # 使用test数据库 &amp;gt; use test switched to db test # 查看test数据库中的集合 &amp;gt; show collections	# 现在test数据库里还没有集合 &amp;gt; </description>
    </item>
    
    <item>
      <title>CentOS7安装Python虚拟环境</title>
      <link>https://xblzbjs.cn/articles/centos7%E5%AE%89%E8%A3%85python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/</link>
      <pubDate>Wed, 17 Mar 2021 10:13:27 +0800</pubDate>
      
      <guid>https://xblzbjs.cn/articles/centos7%E5%AE%89%E8%A3%85python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/</guid>
      <description>virtualenv和virtualenvwrapper安装 pip 3 安装 pip3 install virtualenv -i https://mirrors.aliyun.com/pypi/simple/ 安装virtualenvwrapper工具管理虚拟环境 pip3 install virtualenvwrapper -i https://mirrors.aliyun.com/pypi/simple/ # 报错 [root@centos ~]# pip3 install virtualenvwrapper -i https://mirrors.aliyun.com/pypi/simple/ Looking in indexes: http://mirrors.tencentyun.com/pypi/simple Collecting virtualenvwrapper Downloading http://mirrors.tencentyun.com/pypi/packages/c1/6b/2f05d73b2d2f2410b48b90d3783a0034c26afa534a4a95ad5f1178d61191/virtualenvwrapper-4.8.4.tar.gz (334 kB) |████████████████████████████████| 334 kB 832 kB/s ERROR: Command errored out with exit status 1: command: /usr/local/python3/bin/python3.7 -c &amp;#39;import sys, setuptools, tokenize; sys.argv[0] = &amp;#39;&amp;#34;&amp;#39;&amp;#34;&amp;#39;/tmp/pip-install-f3bmqs9b/virtualenvwrapper_891e91f27f1f44e4b94d4cb51de96c5d/setup.py&amp;#39;&amp;#34;&amp;#39;&amp;#34;&amp;#39;; __file__=&amp;#39;&amp;#34;&amp;#39;&amp;#34;&amp;#39;/tmp/pip-install-f3bmqs9b/virtualenvwrapper_891e91f27f1f44e4b94d4cb51de96c5d/setup.py&amp;#39;&amp;#34;&amp;#39;&amp;#34;&amp;#39;;f=getattr(tokenize, &amp;#39;&amp;#34;&amp;#39;&amp;#34;&amp;#39;open&amp;#39;&amp;#34;&amp;#39;&amp;#34;&amp;#39;, open)(__file__);code=f.read().replace(&amp;#39;&amp;#34;&amp;#39;&amp;#34;&amp;#39;\r\n&amp;#39;&amp;#34;&amp;#39;&amp;#34;&amp;#39;, &amp;#39;&amp;#34;&amp;#39;&amp;#34;&amp;#39;\n&amp;#39;&amp;#34;&amp;#39;&amp;#34;&amp;#39;);f.close();exec(compile(code, __file__, &amp;#39;&amp;#34;&amp;#39;&amp;#34;&amp;#39;exec&amp;#39;&amp;#34;&amp;#39;&amp;#34;&amp;#39;))&amp;#39; egg_info --egg-base /tmp/pip-pip-egg-info-u879bw4z cwd: /tmp/pip-install-f3bmqs9b/virtualenvwrapper_891e91f27f1f44e4b94d4cb51de96c5d/ Complete output (11 lines): Traceback (most recent call last): File &amp;#34;&amp;lt;string&amp;gt;&amp;#34;, line 1, in &amp;lt;module&amp;gt; File &amp;#34;/usr/local/python3/lib/python3.</description>
    </item>
    
    <item>
      <title>CentOS7安装并配置Python3环境</title>
      <link>https://xblzbjs.cn/articles/centos7%E9%85%8D%E7%BD%AEpython3%E7%8E%AF%E5%A2%83/</link>
      <pubDate>Wed, 17 Mar 2021 10:13:27 +0800</pubDate>
      
      <guid>https://xblzbjs.cn/articles/centos7%E9%85%8D%E7%BD%AEpython3%E7%8E%AF%E5%A2%83/</guid>
      <description>环境：腾讯云CentOS7.5 64位
1. 查看Python的位置并安装相关依赖 [root@centos ~]# whereis python python2: /usr/bin/python2 /usr/bin/python2.7 /usr/lib/python2.7 /usr/lib64/python2.7 /usr/include/python2.7 /usr/share/man/man1/python2.1.gz python指向的是python2，python2指向的是python2.7，因此我们可以装个python3，然后将python指向python3，然后python2指向python2.7，那么两个版本的python就能共存了。
yum install zlib-devel libffi-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gcc make 2. 使用wget下载Python3源码包 wget http://npm.taobao.org/mirrors/python/3.7.9/Python-3.7.9.tar.xz # 如果提示wget未找到命令, 那么就先使用yum安装wget yum -y install wget 3. 编译Python3源码包 #解压 xz -d Python-3.7.9.tar.xz tar -xf Python-3.7.9.tar #进入解压后的目录，依次执行下面命令进行手动编译 cd Python-3.7.9 ./configure prefix=/usr/local/python3 make &amp;amp;&amp;amp; make install # 如果出现can&amp;#39;t decompress data; zlib not available这个错误，则需要安装相关库 #安装依赖zlib、zlib-devel yum install zlib zlib yum install zlib zlib-devel 4.</description>
    </item>
    
    <item>
      <title>Django｜第三方库</title>
      <link>https://xblzbjs.cn/articles/django%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/</link>
      <pubDate>Wed, 17 Mar 2021 10:13:27 +0800</pubDate>
      
      <guid>https://xblzbjs.cn/articles/django%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/</guid>
      <description>模型层（model）：   django-model-utils
  django-extensions
  Cookiecutter Django’s documentation
  django-countries
  django-crispy-forms
  factory_boy
  Markdown编辑器:  django-mdeditor  用户注册:  django-allauth: django-registration  后台管理：  django-grappelli simpleui  </description>
    </item>
    
    <item>
      <title>Django｜项目布局</title>
      <link>https://xblzbjs.cn/articles/django%E9%A1%B9%E7%9B%AE%E5%B8%83%E5%B1%80/</link>
      <pubDate>Wed, 17 Mar 2021 10:13:27 +0800</pubDate>
      
      <guid>https://xblzbjs.cn/articles/django%E9%A1%B9%E7%9B%AE%E5%B8%83%E5%B1%80/</guid>
      <description>有许多项目模板可以启动Django项目。这里有两个链接，可使用时，我们引导一个项目:
  cookiecutter-django
  Django包
  默认的项目布局和更好的项目布局 # 默认项目布局  &amp;lt;django_project_root&amp;gt; # 更好的项目布局 &amp;lt;repository_root&amp;gt;/ ├── &amp;lt;configuration_root&amp;gt;/ ├── &amp;lt;django_project_root&amp;gt;/ 仓库根目录 repository_root &amp;lt;repository_root&amp;gt;目录是项目的绝对根目录. 除了&amp;lt;django_project_root&amp;gt; 和 &amp;lt;configuration_root&amp;gt;, 我们还包括其他关键组件像README.md, docs/ directory, manage.py, .gitignore, requirements.txt 文件和其他高级文件部署和运行项目所需的。
 一些开发人员喜欢将&amp;lt;django_project_root&amp;gt;合并到项目的&amp;lt;repository_root&amp;gt;中。
 Django项目根目录 django_project_root 如果使用 django-admin.py startproject，它生成的Django项目将成为项目根目录。
mysite/ ├── manage.py ├── my_app │ ├── __init__.py │ ├── admin.py │ ├── apps.py │ ├── migrations │ │ └── __init__.py │ ├── models.py │ ├── tests.py │ └── views.</description>
    </item>
    
    <item>
      <title>Django｜编码规范</title>
      <link>https://xblzbjs.cn/articles/django%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/</link>
      <pubDate>Tue, 16 Mar 2021 14:51:01 +0800</pubDate>
      
      <guid>https://xblzbjs.cn/articles/django%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/</guid>
      <description>1.编码风格 Coding Style 1.1 代码可读性 6个忠告:
➤ 避免缩写变量名
➤ 写函数参数名。
➤ 解释类和方法。
➤ 对代码进行注释
➤ 将重复的代码行重构为可重用的功能或方法
➤ 保持函数和方法简短。不应该滚动阅读整个函数或方法
1.2 PEP8(Python Enhancement Proposals) PEP8文档
PEP8中文翻译文档
1.3 Python import 格式(以Django为例) # future from __future__ import unicode_literals # 标准包 from math import sqrt from os.path import abspath # Django from django.db import models from django.utils.translation import ugettext_lazy as _ # 第三方包 from django_extensions.db.models import TimeStampedModel # 自己写的包 from .models import BananaSplit # try/except try: import yaml except ImportError: yaml = None CONSTANT = &amp;#39;foo&amp;#39; class Example: # .</description>
    </item>
    
    <item>
      <title>2020书单</title>
      <link>https://xblzbjs.cn/book-list/2020/</link>
      <pubDate>Wed, 30 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://xblzbjs.cn/book-list/2020/</guid>
      <description>技术类 Python  《Python Django开发实战(视频讲解版)》(张虎著) 《Django 3 by Example》(Antonio Mele著) 《Two Scoops of Django 1.11》(Daniel Roy Greenfeld,Audrey Roy Greenfeld) 《深入理解Python特性》()  其他  《程序员修炼之道:通往务实的最高境界》(David Thomas,Andrew Hunt著 云凤译)  </description>
    </item>
    
    <item>
      <title>Python｜深拷贝与浅拷贝</title>
      <link>https://xblzbjs.cn/articles/python%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/</link>
      <pubDate>Thu, 19 Mar 2020 13:36:28 +0800</pubDate>
      
      <guid>https://xblzbjs.cn/articles/python%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/</guid>
      <description>背景： 在开发中，经常涉及到数据的传递。在数据传递使用过程中，可能会发生数据被修改的问题。为了防止数据被修改，就需要再传递一个副本，即使副本被修改，也不会影响原数据的使用。为了生成这个副本，就产生了拷贝。
概念： Python拷贝会涉及到Python中对象、可变类型、引用3个概念，下面一一介绍
 对象：Python对象都拥有三个属性：身份、类型、值。  &amp;gt;&amp;gt;&amp;gt; name = &amp;#34;xblzbjs&amp;#34;	# name对象，值为&amp;#39;xblzbjs&amp;#39; &amp;gt;&amp;gt;&amp;gt; id(name)	# 身份 2016648094384 &amp;gt;&amp;gt;&amp;gt; type(name)	# 类型 &amp;lt;class &amp;#39;str&amp;#39;&amp;gt;  可变类型：在Python中，按更新对象的方式，可以将对象分为2大类：可变对象与不可变对象。
  可变对象： 列表(list)、字典(dict)、集合(set)。所谓可变指可变对象的值可变，身份是不变的。
&amp;gt;&amp;gt;&amp;gt; l1 = [1,2,3] &amp;gt;&amp;gt;&amp;gt; id(l1) 2016648193280 &amp;gt;&amp;gt;&amp;gt; l1 = [1,2] &amp;gt;&amp;gt;&amp;gt; id(l1) 2016648214464 &amp;gt;&amp;gt;&amp;gt; l1[0]=3 &amp;gt;&amp;gt;&amp;gt; l1 [3, 2] &amp;gt;&amp;gt;&amp;gt; id(l1) 2016648214464   不可变对象：数字、字符串(str)、元组(tuple)。不可变对象指对象的身份和值都不可变。新创建的对象被关联到原来的变量名，旧对象被丢弃，垃圾回收器会在适当的时机回收这些对象。
&amp;gt;&amp;gt;&amp;gt; num = 4 &amp;gt;&amp;gt;&amp;gt; id(num) 140710421604224 &amp;gt;&amp;gt;&amp;gt; num = 5 &amp;gt;&amp;gt;&amp;gt; id(num) 140710421604256     引用：在Python程序中，每个对象都会在内存中申请开辟一块空间来保存该对象，该对象在内存中所在位置的地址被称为引用。在开发程序时，所定义的变量名实际就对象的地址引用。引用实际就是内存中的一个数字地址编号，在使用对象时，只要知道这个对象的地址，就可以操作这个对象，但是因为这个数字地址不方便在开发时使用和记忆，所以使用变量名的形式来代替对象的数字地址。</description>
    </item>
    
    <item>
      <title>2020书单</title>
      <link>https://xblzbjs.cn/book-list/2019/</link>
      <pubDate>Mon, 30 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://xblzbjs.cn/book-list/2019/</guid>
      <description>2019 技术类 Python  《Python编程:从入门到实践》(Eric Matthes著) 《流畅的Python》(Luciano Ramalho著)  </description>
    </item>
    
  </channel>
</rss>
